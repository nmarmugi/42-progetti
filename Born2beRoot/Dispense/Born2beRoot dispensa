COME FUNZIONA UNA MACCHINA VIRTUALE E IL SUO SCOPO

Una macchina virtuale (VM) è un software che emula un computer all'interno di un altro sistema operativo. Questa emulazione consente di eseguire più sistemi operativi, fornendo isolamento tra di essi. Questa tecnologia è ampiamente utilizzata per testare nuovi software, consolidare server, migliorare la sicurezza e semplificare la gestione delle risorse hardware.


DEBIAN

Debian è un sistema operativo basato su Linux, noto per essere un sistema operativo open source e gratuito. È uno dei sistemi operativi più popolari all'interno della famiglia Linux ed è utilizzato sia per scopi desktop che server.

Caratteristiche principali di Debian includono:
Stabilità: Debian è noto per la sua stabilità e affidabilità. La sua filosofia è quella di fornire un sistema robusto e sicuro.

Gestore dei pacchetti APT: Debian utilizza il sistema di gestione dei pacchetti Advanced Package Tool (APT), che semplifica l'installazione, la rimozione e l'aggiornamento del software sul sistema.

Ampia selezione di pacchetti: Debian offre un vasto repository di software, che include una vasta gamma di applicazioni, ambienti desktop, server, e molte altre utilità.

Architettura multi-piattaforma: Debian supporta diverse architetture hardware, consentendo l'installazione su una varietà di dispositivi, come computer desktop, server e altro ancora.
Debian è anche la base per molti altri sistemi operativi popolari, tra cui Ubuntu, che è un fork di Debian.


DIFFERENZE TRA DEBIAN E ROCKY

Debian: È un sistema operativo indipendente e non è basato su altre distribuzioni specifiche.
Rocky Linux: È stato creato come alternativa gratuita e open source a Red Hat Enterprise Linux (RHEL). È basato su RHEL e cerca di fornire un ambiente simile senza i costi associati.

Debian: Ha un modello di rilascio di tipo "stabile" che cerca di fornire una piattaforma robusta e testata nel tempo.
Rocky Linux: Cerca di seguire un modello simile a quello di RHEL, offrendo una distribuzione stabile con supporto a lungo termine.

Debian: Ha il suo sistema di gestione dei pacchetti (APT) e un vasto archivio di pacchetti che vanno attraverso rigorosi processi di controllo della qualità.
Rocky Linux: Eredita molte delle caratteristiche e dei pacchetti da RHEL, con il suo sistema di gestione dei pacchetti (YUM/DNF) e il supporto per i repository EPEL (Extra Packages for Enterprise Linux).

Debian: Orientato verso la stabilità e la filosofia del software libero.
Rocky Linux: Orientato a fornire una piattaforma stabile e compatibile con RHEL.


DIFFERENZA TRA APT E APTITUDE

In generale, apt è diventato il comando preferito per molte operazioni quotidiane a causa della sua semplicità, mentre aptitude è spesso utilizzato da chi ha bisogno di funzionalità più avanzate o preferisce un'interfaccia testuale completa. Entrambi gli strumenti sono potenti e possono essere scelti in base alle preferenze personali e alle esigenze specifiche dell'utente. In sintesi apt è più semplice all'utilizzo rispetto ad aptitude, per interfaccia utente, funzionalità avanzate e sintassi dei comandi.


APPARMOR

AppArmor, acronimo di "Application Armor", è un sistema di sicurezza basato su kernel (è il cuore essenziale di un sistema operativo, la componente fondamentale che consente al sistema operativo di funzionare) per sistemi Linux. Il suo scopo principale è fornire un meccanismo di controllo degli accessi basato su policy per limitare le azioni di programmi specifici. AppArmor è spesso utilizzato per aumentare la sicurezza del sistema, proteggendo da potenziali minacce e limitando le capacità dei programmi in esecuzione.
AppArmor definisce policy di sicurezza specifiche per ciascun programma o servizio. Queste policy specificano quali risorse o operazioni un'applicazione è autorizzata a utilizzare.


UFW, FIREWALL E SSH

UFW, acronimo di "Uncomplicated Firewall", è uno strumento di gestione del FIREWALL (è un sistema di sicurezza che controlla e monitora il traffico di rete tra una rete privata e altre reti, come Internet. Il suo scopo principale è quello di proteggere il sistema o la rete da accessi non autorizzati) per i sistemi operativi basati su Linux, in particolare per quelli che utilizzano il sistema di gestione dei pacchetti Debian, come Ubuntu.
UFW include alcune regole predefinite che possono essere facilmente attivate o disattivate per consentire o bloccare il traffico in base a comuni scenari di utilizzo, come ad esempio il traffico SSH ((Secure Shell) è un protocollo di rete crittografato che consente di stabilire connessioni sicure su una rete non sicura, come Internet. Utilizza tecniche di crittografia per proteggere la comunicazione tra due sistemi, consentendo agli utenti di accedere e gestire in modo sicuro un computer remoto attraverso una connessione crittografata).


LVM

LVM, acronimo di "Logical Volume Manager" (Gestore di Volume Logico), è una tecnologia utilizzata nei sistemi operativi Unix e Linux per gestire in modo flessibile lo spazio di archiviazione su dispositivi come dischi rigidi. LVM consente di creare, ridimensionare, spostare e raggruppare volumi logici, offrendo una maggiore flessibilità nella gestione dello storage rispetto ai tradizionali sistemi di partizionamento.

Physical Volumes (PV): I Physical Volumes sono i dischi fisici o le partizioni di dischi che vengono utilizzati da LVM. Questi dischi vengono inizializzati come Physical Volumes e poi possono essere inclusi in un Volume Group.

Volume Group (VG): Il Volume Group è un insieme di Physical Volumes.

Logical Volumes (LV): I Logical Volumes sono le unità di storage logiche create all'interno di un Volume Group. Possono essere considerati equivalenti a partizioni, ma con la flessibilità di ridimensionamento dinamico.

File System: Su un Logical Volume è possibile creare un file system, che rappresenta la struttura di archiviazione dei dati accessibili dal sistema operativo.
In termini pratici, LVM consente agli amministratori di sistema di gestire lo spazio di storage in modo più dinamico rispetto alle partizioni tradizionali. Ad esempio, è possibile estendere un Logical Volume aggiungendo spazio da un Volume Group senza dover riformattare o perdere dati. Questa flessibilità è particolarmente utile in ambienti in cui le esigenze di storage possono cambiare nel tempo.


SCRIPT MONITORING

Uno script di monitoraggio è un programma progettato per controllare, raccogliere e riportare informazioni sullo stato di un sistema, di un'applicazione o di risorse specifiche. Questi script vengono comunemente utilizzati per monitorare la disponibilità, le prestazioni e altri aspetti critici di un sistema informatico. Ecco come generalmente funziona uno script di monitoraggio:

Definizione degli Obiettivi di Monitoraggio:
Prima di scrivere uno script di monitoraggio, è necessario definire gli obiettivi e gli indicatori chiave di prestazione che si desidera monitorare. Ciò potrebbe includere la disponibilità di servizi, l'utilizzo delle risorse, il numero di connessioni attive, ecc.

Sviluppo dello Script:
Lo script di monitoraggio viene scritto per eseguire controlli specifici o per raccogliere informazioni sullo stato del sistema o dell'applicazione. Gli script possono essere scritti in vari linguaggi di programmazione come Bash, Python, Perl, o altri.

Esecuzione Periodica:
Lo script viene eseguito periodicamente, ad intervalli predefiniti. L'esecuzione periodica consente di aggiornare costantemente le informazioni di monitoraggio.

Controllo degli Indicatori di Prestazione:
Lo script verifica gli indicatori di prestazione o esegue controlli specifici in base agli obiettivi di monitoraggio. Ad esempio, potrebbe verificare la risposta di un server web, il consumo di memoria di un'applicazione o lo spazio disponibile su un disco.

Generazione di Report o Allarmi:
Se lo script rileva un problema o un valore al di fuori dei limiti accettabili, può generare un allarme o inviare notifiche all'amministratore di sistema. Alcuni script possono anche registrare dati per analisi storiche o generare report periodici.

Implementazione di Azioni Correttive:
In alcuni casi, uno script di monitoraggio può essere progettato per intraprendere azioni correttive automatiche in risposta a determinati problemi. Ad esempio, potrebbe riavviare un servizio che è andato giù o avviare una pulizia dei file temporanei quando lo spazio su disco è quasi esaurito.

Aggiornamento e Manutenzione:
Gli script di monitoraggio devono essere aggiornati regolarmente per rispondere a nuove esigenze o cambiamenti nell'ambiente. La manutenzione continua è essenziale per assicurarsi che lo script rimanga efficace nel monitorare e rispondere a situazioni critiche.
Gli script di monitoraggio sono uno strumento essenziale per la gestione dei sistemi, consentendo agli amministratori di sistema di identificare e risolvere problemi in modo proattivo, prima che possano causare gravi interruzioni o degradazioni delle prestazioni.


SUDO

"Sudo" è un comando utilizzato nei sistemi operativi basati su Unix e Linux per consentire a un utente di eseguire comandi con i privilegi di un altro utente, di solito l'utente amministratore o "root". La parola "sudo" sta per "superuser do". Quando si utilizza il comando "sudo", viene richiesta la password dell'utente corrente per confermare l'autorizzazione a eseguire il comando con privilegi elevati.
Ad esempio, se vuoi installare un software o apportare modifiche di sistema che richiedono privilegi amministrativi, puoi utilizzare "sudo" per ottenere temporaneamente quei privilegi senza dover effettuare l'accesso completo come amministratore. L'uso di "sudo" contribuisce a migliorare la sicurezza, limitando l'accesso privilegiato solo agli utenti autorizzati.


CRON

Cron è un servizio nei sistemi operativi Unix e Unix-like (come Linux) che consente la programmazione di attività automatiche in base a un orario o a intervalli di tempo specifici. Il nome "cron" deriva dalla parola greca "chronos", che significa tempo. È uno strumento fondamentale per l'automazione delle attività periodiche nel sistema.

Ecco come funziona cron:

Tabella di Cron:
Il cuore di cron è una tabella di pianificazione chiamata "crontab". Ogni utente può avere la propria crontab, che contiene una lista di comandi e il momento in cui devono essere eseguiti.

Sintassi della Crontab:
La sintassi di una crontab è divisa in cinque campi principali che specificano quando un comando deve essere eseguito: minuti, ore, giorni del mese, mesi e giorni della settimana. Ad esempio, l'istruzione 0 2 * * * significa "alle 2:00 AM di ogni giorno".

Comandi Cron:
I comandi inseriti nella crontab possono essere qualsiasi comando di shell valido. Possono essere script, eseguibili o comandi di sistema.
In sintesi, cron è uno strumento potente per automatizzare attività ricorrenti nei sistemi Unix-like, consentendo agli utenti di pianificare esecuzioni periodiche di comandi o script.


RAM

La RAM (Random Access Memory) è una forma di memoria temporanea utilizzata dai computer per archiviare dati e istruzioni temporaneamente mentre il sistema è acceso. È più veloce della memoria di archiviazione a lungo termine, come l'hard disk, ma perde tutti i dati quando il computer viene spento. La RAM consente al computer di accedere rapidamente ai dati necessari per eseguire programmi e processi.


CPU

La CPU (Central Processing Unit) è il componente principale di un computer responsabile dell'esecuzione delle istruzioni di un programma e del controllo delle operazioni del sistema.


PLUS

retry=3 ➤ Tre tentativi di inserimento password.

minlen=10 ➤ Il numero minimo di caratteri che la password deve contenere.

ucredit=-1 ➤ Almeno una lettera maiuscola. (Mettiamo il - perché deve contenere almeno un carattere, se mettiamo + intendiamo al massimo quei caratteri.)

dcredit=-1 ➤ Deve contenere almeno una cifra.

lcredit=-1 ➤ Deve contenere almeno una lettera minuscola.

maxrepeat=3 ➤ Non può contenere più di 3 volte di seguito lo stesso carattere.

reject_username ➤ Non può contenere il nome dell'utente.

difok=7 ➤ Deve contenere almeno 7 caratteri che non fanno parte della vecchia password.

enforce_for_root ➤ Verrà implementata questa politica per l'utente root.
/////////////////////////////////////////////////////////////////////////////////////////////////////
Defaults passwd_tries=3: Imposta il numero massimo di tentativi consentiti per immettere la password prima che sudo restituisca un errore.

Defaults badpass_message="Messaggio di errore personalizzato": Specifica un messaggio di errore personalizzato che verrà visualizzato in caso di inserimento di una password errata.

Defaults logfile="/var/log/sudo/sudo_config": Specifica il percorso del file di log per le attività di sudo.

Defaults log_input, log_output: Abilita la registrazione di input e output dei comandi eseguiti con sudo.

Defaults iolog_dir="/var/log/sudo": Specifica la directory in cui verranno memorizzati i file di log delle sessioni di input/output di sudo.

Defaults requiretty: Richiede un terminale per l'esecuzione di comandi con sudo. Può essere disabilitato se si sta eseguendo sudo da uno script o da un ambiente senza terminale.

Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin": Imposta un percorso sicuro per gli eseguibili che possono essere eseguiti con sudo, limitando il rischio di esecuzione di comandi dannosi.
/////////////////////////////////////////////////////////////////////////////////////////////////////
ARCH, CPU PHYSICAL, CPU VIRTUAL, RAM:
        arch=$(uname -a): Ottiene e salva le informazioni sull'architettura del sistema.
        cpuf=$(grep "physical id" /proc/cpuinfo | wc -l): Conta il numero di CPU fisiche.
        cpuv=$(grep "processor" /proc/cpuinfo | wc -l): Conta il numero di CPU virtuali.
        ram_total, ram_use, ram_percent: Ottiene le informazioni sulla memoria RAM totale, utilizzata e la percentuale di utilizzo.

DISK:
        disk_info: Ottiene e formatta le informazioni sul disco, sommando la dimensione totale e l'utilizzo di tutte le partizioni.
        disk_total, disk_use, disk_percent: Estrae la dimensione totale, l'utilizzo e la percentuale di utilizzo dalla variabile disk_info.

CPU LOAD:
        cpul=$(vmstat 1 2 | tail -1 | awk '{printf $15}'): Ottiene l'utilizzo della CPU negli ultimi 2 secondi.
        cpu_op=$(expr 100 - $cpul): Calcola l'uso percentuale rimanente della CPU.
        cpu_fin=$(printf "%.1f" $cpu_op): Formatta il risultato come un numero decimale con una cifra dopo la virgola.

LAST BOOT, LVM USE, TCP CONNECTIONS, USER LOG, NETWORK, SUDO:
        lb=$(who -b | awk '$1 == "system" {print $3 " " $4}'): Ottiene la data e l'ora dell'ultimo avvio.
        lvmu=$(if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo yes; else echo no; fi): Verifica se LVM è in uso.
        tcpc=$(ss -ta | grep ESTAB | wc -l): Conta il numero di connessioni TCP stabilite.
        ulog=$(users | wc -w): Conta il numero di utenti collegati.
        ip=$(hostname -I), mac=$(ip link | grep "link/ether" | awk '{print $2}'): Ottiene l'indirizzo IP e l'indirizzo MAC.
        cmnd=$(journalctl _COMM=sudo | grep COMMAND | wc -l): Conta il numero di comandi eseguiti con sudo.

    wall:
        wall: Invia un messaggio a tutti gli utenti terminali. Il messaggio include le informazioni raccolte nei passi precedenti.
